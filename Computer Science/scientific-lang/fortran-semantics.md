Corner cases of Fortran semantics that can't be embedded into C/C++ or the like in an easy way
============

  
# Arrays

## Zero-size arrays???

First, in Fortran we have arrays with zero size.
This of course is not normal in C.

## Interaction between different arrays types: function call

The next question is, whether attributes like 
`real, dimension(3)` and `real, dimension(4)` 
can be neatly considered as *types* - dependent types, actually - 
as in general purpose languages.
That's to say, whether the behavior of variables and arguments with these attributes 
in function calls and assignments 
can be captured by subtyping, implicit case, etc.
The behaviors described below are
exemplified in fortran-reference/array-passing.f90.

It seems in a function call, 
the dummy variable will try its best to convert the 
it can be clearly seen in attempts to convert Fortran codes to C/C++
(like https://cci.lbl.gov/fable/)
where we have  
```C++
void sf(arr_cref<float> abcss, /*...*/)
{
    abcss(dimension(3));
    // ...
}
```
in place of 
```fortran
subroutine sf(abcss, ...)
implicit none
REAL :: abcss(3)
!...
```
and `abcss(dimension(3))` truncates 
(or, more appropriately, hides, because the array variables like `abcss` 
may be seen as array descriptors which point to an allocated memory space, 
and modification of the array descriptor) 
`abcss` to a three-element array if the length of `abcss` is longer than 3;
when `abcss` is smaller than 3, a compilation error is thrown; 
but this behavior can be worked around by the follows:
```fortran
print *, "Applying sum_assumed_size (size=5) on alloc", sum_assumed_size(alloc, 3)
!...
contains
!...
function sum_assumed_size(arr, n) result(res)
    real, intent(in), dimension(n) :: arr
    integer, intent(in) :: n
    real :: res
    
    res = sum(arr)
end function sum_assumed_size
```
Note however the `arr`  dummy argument is an *automatic* array, 
not a fixed size array; the behavior therefore is expectedly different.

## Interaction between different arrays types: Assignment 

Assignment between arrays with different ranks has a different semantics - 
see 7.2.1.3 Interpretation of intrinsic assignments of [the J3/10-007 specification](https://j3-fortran.org/doc/year/10/10-007.pdf).

## Discussion on Fortran array semantics

There are several immediate conclusions that can be drawn from the above discussion,
First, assignment and function calling are very different in Fortran,
and both of them have complicated semantics.
If we are to embed the Fortran semantics to a more domain general language, like C++,
it might be helpful to conceive array variables as *values* of the array descriptor type 
(i.e. not pointers to array descriptors), 
and the assignment operator is overloaded to enable this complicated behavior;
the behaviors of argument association may be captured by 
defining a macro like `FORTRAN_FUNCTION`, 
which automatically generates the aforementioned `abcss(dimension(3));` lines.

That's to say,
there is no need to think that the attribute combinations define various array types:
it's more helpful to conceive Fortran arrays as something similar to `np.array`,
maybe `fortran.array` in a general purpose language,
although the Fortran array contains much more flags (i.e. the attributes like `allocatable`); 
the fact that `gfortran` will prevent some function calls, like 
```fortran
real, dimension(3) :: r
! ...
print *, "Applying sum4d to a 3d array ", sum4d(r)
```
is simply because this looks like an obvious error; 
it can be well emulated by dictating that once a `fortran.array` is initialized in a fixed-size way, 
its size is never changed by the `=` operator, 
and can only be reduced by the `arr(dimension(...))` call 
automatically generated by `FORTRAN_FUNCTION`
and since the function call `sum4d(r)` involves the `r(dimension(4))` line, 
which tries to enlarge it, the function call fails,
and the Fortran compiler - now as a compiler of a DSL - reports the problem which is bound to appear at runtime.
The reason why this behavior is chosen is not out of any prudent theoretical reckoning, 
but is merely an arbitrary choice, presumably related to the implementation of the array 
(enlarging an allocated slot in memory is hard and not efficient, etc.);
`arr(dimension(size_smaller_then_arr))` would be fine, 
because this can be easily implemented by just changing the array descriptor. 
But then that's it - no further discussion on an elegant theoretical model for this behavior is needed.
Similarly `array_declared_as_4_element = array_declared_as_3_element` doesn't work, 
maybe because of memory management issues - but then that's it, 
that's just an ad hoc convention and needs no further investigation.

The existence of Fortran as an important strongly typed language 
also demonstrates that sometimes, *not* conceiving type systems as those in typed lambda calculi 
and instead conceiving type systems as compiling stage reasoning about what will happen in a dynamically-typed language  
helps to under real-world languages better.
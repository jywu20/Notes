- 全函数：在每一个点都停机；“$x$上$f(x)$停机”简写为$f(x) \uparrow$
- 偏函数：在一些点不停机；“$x$上$f(x)$不停机”简写为$f(x) \downarrow$
- 原始递归函数：四则运算、条件判断、有限for循环；它们都是全函数
- 递归函数：加上了正则极小化运算$\mu$。所谓的极小化运算$\mu z P(z)$寻找最小的让$P(z)$成立的$z$；一个一般的极小化运算允许无界for循环或者无限制的while循环，此处所谓“正则”要求循环一定停机
- 部分递归函数：加上了无限制的极小化运算，即允许不停机

部分递归函数等价于图灵机。递归函数的性质不是特别好，因为正则性的判定（也就是说，停机问题）并不是能行可计算的：we have to handle it case by case as there is no algorithm that automatically decides it for us。

克林尼正规型定理：存在一个原始递归函数$U$和三元原始递归谓词$T$，使得对任意部分递归函数$f$，都存在自然数$e$使得$f(x) = U(\mu z T(e, x, z))$.
因此原则上只需要使用一次未必停机的循环和一些原始递归函数就能够构造出所有算法。

一个函数是递归的当且仅当它是部分递归的全函数。

以下说法等价：
- 集合$A$是递归可枚举的（“枚举”一词的意义见下面三个条件；注意我们只能说一个集合是递归可枚举的，并不能说一个函数是递归可枚举的）
- $A$或者是空集或者是某个递归全函数的值域
- $A$或者是空集或者是某个原始递归函数的值域
- $A$或者是空集或者是某个部分递归函数的值域（即不停机的点被抛弃了）
- $A$是某个部分递归函数的定义域
- $A$的部分递归函数——如果$x \in A$则$f(x) = 1$，否则$f(x) \uparrow$——是部分递归的
- 存在原始递归谓词$R(x, y)$使得$A = \{ x | \exist y R(x, y) \}$

以下说法等价：
- 集合$A$是递归的
- $A$的特征函数是递归的
- 其补集是递归可枚举的

总是存在一个算法来确认一个元素在一个递归可枚举集合中，但是没有算法能够普适地判断一个元素*不在*一个递归可枚举集合中。

克林尼正规型定理实际上说明了图灵完备并不是特别困难的事情。作为一种娱乐，一些人会热衷于寻找你绝对想不到它图灵完备可是实际上就是图灵完备的系统，比如说PPT。
在做这些事情的时候需要注意下面两点：
- 物理上能实现的机器不可能真的图灵完备，因为所有能造出来的机器的内存都是有限的。可是一台有限的机器的输出不也是有限的吗？那么是否物理上能实现的机器全都等价于一张巨大但是有限的把程序输入映射到程序输出的表格上面呢？
  
  实际上，当我们说某某是图灵完备的时候，我们实际上是在说它的架构满足如下的条件：在不对系统架构做大的修改的前提下，可以通过加入越来越多的内存来让机器的计算能力越来越接近图灵机。
  
  一张look-up table是不满足这个条件的：要加入更多的行，那么每一行的输入对应的输出都必须手动填写上去。
  现代计算机架构是满足这个条件的：虽然CPU的寻址空间受到CPU的一条指令的长度的限制（如32位系统只能用4G内存），但是可以通过诸如Physical Address Extension之类的技术来解决这个限制。

  总之，分析一台具体的机器是不是图灵完备是没有意义的，因为它肯定不图灵完备；分析一个架构是不是图灵完备是有意义的，但是要小心。  
- 一个架构是图灵完备的不代表它就能做所有我们想让它做的事情，原因是显然的：例如只有命令行的机器没法画彩图，虽然我们可以让它把屏幕上各个点应该有的颜色标注在一个巨大的矩阵里。一旦事情涉及到和外界的交互，理论性地分析什么是能做到的什么是理论上就不能做到的就变得困难了。

  一个不那么平凡的例子是，虽然C++的类型系统是图灵完备的，但是有些功能就是要编译器开洞实现，因为C++提供的primitive不足以让编译期的代码获得关于一个类型的足够多的信息。
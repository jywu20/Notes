# 构造演算

## motivation

首先我们应该明确一件事：实际上数学并没有一个真的无可置疑的基础。
的确，原则上可以用传统平面几何的方式做微积分计算，甚至可以使用很多我们绝对想不到的体系做数学的基础。
因此，数学基础更多的起到的是“心安”的作用：它用于判断：

1. 我们的哪些推理是可信的；
2. 我们的哪些数学构造可以认为是存在的。（比如说，也许满足皮亚诺公理的对象根本就不存在呢？）

关于前者，一阶逻辑是典范；关于后者，集合论很大程度上就是用来做这件事的。我们研究集合一方面是为了单纯引入“集合”这一概念，一方面是为了做**构造**：表明自然数是可以构造出来的，等等。

然而，集合论在构造这件事上实际上并不自然，只需要简单地看一看自然数在集合论中的繁复定义就可以确信这一点。
实际上，集合论对确保数学对象的存在性这件事的处理是非常ad hoc的：它诉诸了一些“什么样的集合是存在的”的公理，而在实际的数学操作中，我们更希望简单地“写出我们想要的对象的所有性质”，然后检查它是否存在。

此外，集合论+一阶逻辑的表述也没法捕捉下面的事实：映射等概念一而再再而三地出现，而集合论只是简单地将它们编码为元素对；直觉上看，等词在定义中的作用和“当且仅当”是一样的，但是在一阶逻辑中前者是谓词而后者是逻辑运算符；数学证明、命题本身可以被当成数学对象（不是在元语言中），而集合论+一阶逻辑根本处理不了这种东西，而需要非常繁冗的元数学；此外，不少集合论公理和逻辑推导规则实际上是可以互换的，那么更加优美的方案显然应该将这些东西“融为一体”才行。
实际上这也反映了集合论+一阶逻辑的formalism的一个很大的问题，就是要扩展它非常不便。

一种可能的解决方案是引入高阶逻辑，但是实际上这等同于引入了类型论。
还有一种解决方案是使用符号推导系统（如Mathematica），但是首先这就把一阶逻辑当成了某种可以拿来做计算的“表达式”，和常见的句法证明风格很不搭；其次这种approach也可以容易地用构造演算实现。

对引入类型论formalism的一种可能的反驳是：它太“大”了，可以任意地做软件开发、程序验证、证明辅助，而我们只需要一个简单的theorem prover而已！
但是，如果我们局限在传统处理方式中，那么软件开发、程序验证等“额外功能”都需要开发额外的形式系统来处理，又需要撰写大量“接口”性质的定义、定理、证明使得我们能够以一种“数学”的方式处理它们：例如说，我们需要在一阶逻辑加集合论的框架中严格定义程序行为，需要定义一个Hoare逻辑（然后因为prover未必支持扩展一阶逻辑，还需要在FOL prover中弄一些语法糖来把Hoare logic转化为FOL命题），可能还需要很多元数学的论证（结果就是普通的证明和这些元数学论证竟然还不能写在一个文件里面）——但是引入大量元数学本身也是非常“大而无当”的做法，还凭空增加了很多苦力活。
相比之下，能够在一个统一的框架中完成所有这些事情而不需要和元数学打太多交道也许是更好的选择。

从某种意义上，传统的一阶逻辑加集合论就像正则表述，而归纳构造演算以及类似的其它类型论方法就像路径积分表述，前者看起来更加符合直觉、更加“简洁”、可以用于描述后者，然而处理越复杂的问题就越显得力不从心：需要同时考虑的因素实在太多了。
后者一开始看起来缺乏motivation，但是实际上更加便于一般化的处理，并且一旦熟练掌握，工作效率可以大大提高。

需要注意的是在特殊情况下使用FOL可能反而更加方便，例如有很多automated theorem prover in FOL。这就好像很多量子模拟还是会使用哈密顿量那一套东西一个道理。
此时使用FOL当然是最好的。

总之，FOL适合用作形式化理论的“入门理论”，并为其它框架的有效性提供辩护，也适用于一些特殊任务，但是工程化的、scalable的形式化方法，也许CIC之类的typed lambda calculus真的是更好的选择，正如物理中可以从正则表述导出的路径积分表述实际上更适合抓住物理实际无脑算而不必分析tricky的各种细节一样。
路径积分和CIC乍一看让人感觉“有些道理但是不知道在干什么”，但是一旦摸透它的用法——bingo! Everything works out.

当然，是不是真的要引入全套CIC还是一个问题。例如Isabelle就采用了一种理论中立的方法：它本身可以称为一种Weak type theory，但是没什么人会直接拿它写证明，都是引入各种公理之后得到Isabelle/ZF, Isabelle/HOL。实际上在Isabelle/ZF中你并不需要写很多涉及类型的东西，因为一切都封装好了。

总之大概的思路是：

1. 定义一阶逻辑：自然演绎，sequential calculus和two liners，命题、谓词，直觉主义
2. 定义集合论，ZFC
3. 表明集合论加一阶逻辑可以formalize全部数学；集合论中很多公理的作用是证明一些东西的存在性
4. 特别的，有图灵机和lambda calculus；可以形式验证；逻辑命题的可判定性；
5. 指出集合论+一阶逻辑在实际使用中的不便：一切皆集合，那么随便拿两个对象可以进行任何操作，这种风格不像通常做数学的风格；“映射”的概念在数学中具有非常重要的地位，然而集合论没有体现这一点；lambda calculus中的函数作用和逻辑推理非常相似，然而不能统一地处理它们；看不出函数定义的可计算性
6. 构造演算：给变量加上类型标签；给lambda表达式定类型；确定类型的类型；C-H同构，构造演算就是直觉主义逻辑；构造演算一定可停机；如何构造是不是停机不知道的东西；如何加入排中律；构造演算是通常的typed lambda calculus中最强的
7. 阉割构造演算，得到lambda cube
8. 在构造演算中做数学证明，导出一阶逻辑
9. 这就是顶峰了：剩下的都是各种应用

总之，可以在构造演算中得到一阶逻辑，定义集合（包括ZFC集合和类）、自然数、列表等基本概念，定义各种抽象代数结构，定义范畴论，然后可以得到整个数学。
这样的模式相比从集合出发建立一切，更加合乎实际的数学实践——我们保证了证明过程中的每一个对象都是带有标签的（类型论的作用），避免了不自然的“编码”（无论是用集合编码万物还是用范畴论中的态射什么的编码集合论中“属于”的关系，还是别的什么），省去了不必要的存在性证明（如果一个结构可以不附加公理地定义出来那么它肯定存在），并且无需频繁涉及元数学（例如如果两个概念是对偶的，那么把对某个定理的证明中的一个概念替换成另一个概念可以得到一个对偶定理的证明；这件事是没法在一个一阶逻辑中自己得到证明的而必须用到它的元语言，但是构造演算中证明本身是一种term，那么就不会有问题），保留了传统的结构主义数学风格，这样可以得到一个非常“典范”的系统。

一点私货：虽然形式主义者们喜欢说数学实际上就是毫无意义的符号游戏，但是出于某些原因我们还是可以直觉地感受到一些东西更像数学而另一些东西更加不像数学。
例如，将四书五经形式化也不是不可以，但是这样弄出来的东西似乎“缺乏让人感兴趣的结构”。
某种意义上，自然演绎逻辑那种“有一个$A \to B$的定义，把它运用到$A$上面”的思维方式是非常放之四海而皆准的，而如果我们不局限在传统的元数学的思维方式上，而是把命题、证明也看成无需元语言也可以（在对象语言中）操作的“东西”，那么“用箭头把点联系起来”就是最基本的思维方式——在逻辑中这是自然演绎逻辑，在抽象代数中这是范畴论，在计算机科学中这是类型论，在物理中这是各种“变换”（时间演化、对称性操作，等等）。
从这个底层的“用箭头把点联系起来”的机制出发可以自然地产生各种各样的结构，同样这些东西在逻辑、代数、理论计算机科学、理论物理等领域会一而再再而三地出现。
例如量子场论是以坐标点（来自一个空间，这个空间有拓扑结构，等等）为标签的量子力学，然后可以把各种东西全部都联系起来。
总之的确有一个“典范”的数学体系，它在逻辑上是无懈可击的，在物理上是well-motivated的，在计算机科学上是有计算上的意义的，等等。

当然真的要把这一套东西形式化那还是非常麻烦的。我倒是不觉得有必要拿范畴论做数学基础，因为这样不可避免在公理层面就需要讨论“范畴的范畴”，而无穷范畴的很多性质并不那么显然，而我们通常认为数学基础应该足够合直觉，然后推出不那么显然的东西。

## CoC的定义

CoC中的每一个Judgement都形如$\Gamma \vdash x:A$，即“从一组假设可以推导出$x$属于某个类型”，其中$x$是一个term而$A$是一个类型（类型也是一种特殊的term）。
但是要注意“类型”在这里并不是一种奇怪的集合，而只是一个term的某种标签而已。
实际上，真的做数学证明时我们未必就会频繁地分析“某个term到底是不是属于某个类型”——**命题**并不会被编码为$x:A$的形式。

term包括这么几种：

- $\mathrm{Type}$
- $\mathrm{Prop}$，所有命题都具有此类型；Prop的存在体现了CoC“数学”的一面，很多其它类型系统也可以用来做证明，但是并没有一个显式的Prop
- 变量$x, y, z$等等
- 常量，预先设置好类型和值的一些东西；它和变量的区别在于变量可以参与$\forall$引入，可以被$\forall$约束而常量不行；
- 若$A$和$B$都是term，那么$AB$也是；使用更加通常的记号，$AB$其实是$A(B)$，就是把$A$当成一个函数来调用，$B$是参数
- 若$A$和$B$都是term而$x$是变量，那么$\lambda x:A. B$和$\forall x:A, B$都是term；前者就是普通的带类型的lambda表达式，后者是lambda表达式本身的类型（为什么使用$\forall$符号一会会看到）

---

**注意**

CoC中的变量和编程语言里面那种mutable variables是不一样的，因为它代表将被全称量化的那些符号。一般的编程中不会有这种东西。
实际上CoC中的常量反而和函数式编程中的immutable比较接近，需要而且只能被赋值一次。

---

现在来看推导规则：

- Prop本身的类型是Type：
  $$
  \frac{}{\Gamma \vdash \mathrm{Prop}:\mathrm{Type}}
  $$
- 自然演绎逻辑中常见的推导规则，就是可以随意地从已知命题中拿一个出来用：
  $$
  \frac{}{\Gamma, x:A, \Gamma' \vdash x:A}
  $$
- 给$\forall x:A.B$确定类型，$A:K$之类的东西是为了保证确确实实有一个类型$A$（下同）：
  $$
  \frac{\Gamma \vdash A:K, \quad \Gamma, x:A \vdash B:L}{\Gamma \vdash (\forall x:A, B) : L}
  $$
- 给lambda表达式定类型：
  $$
  \frac{\Gamma \vdash A:K, \quad \Gamma, x:A \vdash N:B}{\Gamma \vdash (\lambda x:A.N): (\forall x:A,B)}
  $$
- 给“函数调用”的结果定类型，$x:=N$指的是把$B$中但凡有$x$出现的地方的$x$都换成$N$：
  $$
  \frac{\Gamma \vdash M: (\forall x:A, B), \quad \Gamma \vdash N:A}{\Gamma \vdash MN: B[x:=N]}
  $$
- $\beta$规约不改变类型，所谓$\beta$规约指的是把函数调用算出来，也就是说把$(\lambda x:A.B)(a)$替换成$B[x:=a]$；需要显式引入这个规定是因为上面几条规则只是说了“函数调用的返回值满足如何如何的类型”，但是根本就没有说函数调用实际上是怎么操作的，所以需要专门提一句：
  $$
  \frac{\Gamma \vdash M:A, \quad \Gamma \vdash A =_\beta B, \quad \Gamma \vdash B:K }{\Gamma \vdash M:B}
  $$

$\forall$有时也可以写成$\prod$。

到现在为止为什么需要定义这些规则并不十分清楚，不过还是有一些模糊的线索。例如我们可以模糊地看出$\forall$类型似乎允许函数返回值的类型依赖于输入值。
具体这些规则是干什么用的见后。

CoC有一些东西没有给出：

- 排中律：CoC对应直觉主义逻辑，排中律并不总是成立（原因也很好理解：由于C-H同构，排中律实际上是要求输入一个命题，可以自动判断它是真命题还是假命题（见“一阶逻辑”一节），而由于CoC容纳了一阶逻辑，这项任务超出了图灵机的能力）排中律实际上是call/cc的类型（更准确地说，皮尔士律是call/cc的类型而皮尔士律和排中律等价），而可以证明，使用lambda calculus不能构造出call/cc运算。但应当指出，lambda calculus本身是图灵完备的，因此所有用到了call/cc运算的程序都可以写成等价的没有用到call/cc运算的程序；这个过程在逻辑学上对应哥德尔-根岑变换（把对命题$p$的经典逻辑证明转化为对$\lnot \lnot p$的直觉主义逻辑证明），在lambda calculus中可以以CPS变换实现。CPS变换本身则可以在lambda calculus中完成，但是这样的“实现”对应的不是对象语言中的证明，而是元语言中的了。
- 怎样判断两个东西相等（广延性）：这些留给用户自己定义
- 图灵完备性：是的，CoC虽然是typed lambda calculus，但是并不图灵完备，在CoC中能够良定义的函数（就是能够用lambda表达式写出来，并且能够有一个类型的term）可以将一个图灵机计算任意步，但是就是不能写出死循环，因为CoC是强正规的；图灵机还是可以作为数据在CoC中被分析，但是默认并不能执行（这也是C-H同构带来的结果，因为死循环的程序会导致对应的逻辑系统出现inconsistency，原因也很简单：不接受任何参数的死循环的程序很容易构造出来，然后它不停机，所以也没有返回值，因此死循环的程序的类型为"False"（通常记作bottom，$\bot$），而既然死循环到处都可以写出来，对任何类型$A$，类型$A \to \bot$总是有实例的，这样逻辑系统就是不自洽的，因为每个命题都可以被否定；关于怎么妥善地处理可能有死循环的程序仍然没有非常一致的意见，通常是用monad把可能出问题的代码隔离出来）

关于构造主义的评注：在CoC中可以更加清楚地看到为什么构造主义反对排中律。
在普通的一阶逻辑中，如果接受排中律，就可以从$\lnot \forall x P(x)$推导出$\exist x \lnot P(x)$，显然这并没有给出怎么构造满足条件的$x$。如果不接受排中律，那么一切存在命题最终可以追溯到某个被设定为公理的存在命题。但同样，由于一阶逻辑中并没有显式的“构造”的概念，从一个存在命题到另一个存在命题的推理恐怕也很难说是构造性的还是不是构造性的。
在CoC中确保对象存在的公理被没有赋值的常数声明$a : A$取代，而CoC中“映射”是基本语言的一部分，那么任何对存在性的证明都可以从一组初始对象通过某些函数调用真正显式地“构造”
出想要的对象来完成。


# 构造演算的子系统

## 一阶逻辑

我们首先来看看，CoC是不是可以容纳一阶逻辑。

我们将看到，类型代表命题，而具有某个类型的term则是这个命题的证明。
（$\forall x:A, B$中的$A$未必代表逻辑命题，它可以只是为了避免“把集合和数乘起来”之类的反直观操作，当然也可以代表逻辑命题）
公理没有证明，因此就是$x:A$这样没有赋予实际值的声明；定理有证明，因此形如$x:A=\cdots$，其值就是证明。
这样，有某个term以之为类型的命题就是真的，或者说，能够被实现的函数签名都是真命题。
从计算的角度，定理是definition而公理是declaration，因为定理需要证明，所以需要被赋予一个实际的值，而公理不需要被证明，只需要声明就可以。

我们首先来看命题逻辑。设类型$A, B, C$等表示逻辑命题，定义

- $A \rightarrow B$定义为$\forall x:A, B$，其中$B$不含$x$

这样的定义合理吗？首先我们容易看出
$$
\frac{\Gamma \vdash A:\mathrm{Prop}, \quad \Gamma \vdash B:\mathrm{Prop}}{\Gamma \vdash (A \rightarrow B): \mathrm{Prop}}.
$$
其次我们来看一看$\rightarrow$引入和消去规则是不是成立。再次提醒，$A$成立指的是能够找到一个term使得$x:A$。
$\rightarrow$引入规则成立，因为如果$A$和$B$都成立，那就有$x:A$且$y:B$，从而lambda表达式$\lambda x:A. y$的类型就是$\forall x:A.B$，从而$A\rightarrow B$可以被证明。
$\rightarrow$消去规则也成立，这是显然的，因为只需要将$A \rightarrow B$的证明当成函数作用在$A$的证明上就可以得到$B$的证明，从而$B$确实成立。
因此以上逻辑蕴涵的定义是合理的。

我们还看到，$A \rightarrow B$的证明实际上就是读入$A$的证明，输出$B$的证明的一个函数，这从另一个角度展现了C-H同构的意义。

逻辑蕴涵定义好之后，我们假定$\rightarrow$为右结合的，并且定义其它逻辑运算符：

- $A \land B$定义为$\forall C:\mathrm{Prop}, (A \rightarrow B \rightarrow C) \rightarrow C$
- $A \lor B$定义为$\forall C:\mathrm{Prop}, (A \rightarrow C) \rightarrow (B \rightarrow C) \rightarrow C$
- $\lnot A$定义为$\forall C:\mathrm{Prop}, A \rightarrow C$
- $\exist x:A, B$定义为$\forall C:\mathrm{Prop}, (\forall x:A, B \rightarrow C) \rightarrow C$

所有这些运算符都是特殊的函数：它们读入两个命题，输出一个命题。（和标准的一阶逻辑不同，在CoC中$\forall$的引入和消除规则是自带的，而其余逻辑运算符的引入和消除规则都是构造出来的函数；在这里我们看到了CoC的另一个好处：证明策略——“要证明A只需要证明B”——实际上就是一个读入一个命题而输出另一个命题的函数，从而没有必要使用元语言就能够定义和使用证明策略，大大简化了问题）
在CoC中我们可以很容易地讨论“这个运算符如何如何”，而在纯粹的一阶逻辑中这种讨论只能在元语言中进行。

有一件事需要注意：在CoC中$\leftrightarrow$和$=$不是一回事。两个类型满足$A \leftrightarrow B$意味着任何一个以$A$为类型的term都可以通过某个映射变换为一个以$B$为类型的term，反之亦然，即两者保存了同样多的信息。
但是这并不意味着它们就“相等”。当然实际上可以引入一个公理让它们相等，因为说到底，任何一个构造肯定都要依赖一些primitive notations，而功能相同的primitive notations是不是一样，这种问题就没什么意义了。

上面的逻辑运算符的定义依赖于$\mathrm{Prop}$类型。实际上还有更加一般的定义。
TODO

## dependent type

既然命题逻辑在CoC中被实现了，那么由C-H同构，自然可以得到一个类型系统。而实际上CoC能做的比这还要多，因为（显而易见的）类型可以依赖于一些term，即有dependent type。

先来看比较简单的、不dependent的类型。首先我们有product type，$A \times B$，直观上它是一个二元素有序对的类型，第一个元素类型为$A$，第二个元素类型为$B$，即
$$
\Gamma, x:A, y:B \vdash (x, y) : A \times B.
$$
逻辑上这就是$\land$引入规则，于是可以记product type为$A \land B$。
实际上我们之前已经定义过$A \land B$了，所以实际上可以巧妙使用lambda表达式定义出$(x, y)$。（当然实际的prover不会绕这种弯子，tuple都是自带的）
同样也可以有
$$
\Gamma, x_1 : A_1, \ldots, x_n : A_n \vdash (x_1, x_2, \ldots, x_n) : A_1 \times A_2 \times \cdots A_n
$$
由于不同位置的元素可以具有不同的类型，product type实际上就是结构体。

其次我们也有sum type，$A \lor B$。一个$A \lor B$可以保存一个$A$类型的值，也可以保存一个$B$类型的值。
在$A$和$B$互斥时可以将它理解成集合的并集，但是如果$A$和$B$相交，那么$A \lor B$实际上是$\{ (x, 1) | x \in A \}$和$\{ (x, 2) | x \in B \}$的并集。
这里的关键在于我们必须能够识别出一个$A \lor B$类型的term保存的是$A$类型的数据还是$B$类型的数据。
很容易看出$A \lor B$实际上就是共用体。

我们有$A \land B \to A \lor B$，因此有些语言中会用product type代替sum type，但是这样会浪费存储空间，并且可能会遗留一些没考虑到的corner case。

然后我们来分析dependent types。首先我们有dependent product type，即$\prod$类型。这或许是最容易想到的一种dependent type。例如，设$\mathrm{Tuple}(A, n)$代表$n$个类型为$A$的对象构成的元组，则
$$
\forall n : \mathrm{nat}, \mathrm{Tuple}(A, n)
$$
就是读入一个自然数$n$，输出某个$n$元元组的函数的类型。特别的，$B$可以不显含$x$，此时$\forall x:A, B$简写为$A \rightarrow B$，这实际上就是将类型$A$的数据映射为类型$B$的一个函数。

然后是dependent sum type，它是dependent product type的对偶。我们知道$\forall$的对偶是$\exist$，即dependent sum type在逻辑中对应一个存在命题。
要证明一个存在命题$\exist x:A, B(x)$，就是要找到一个$x:A$，使得$B(x)$能够被证明，也即，要找到一对$(x,y)$使得$x:A$且$y:B(x)$。
因此我们就有
$$
\Gamma, x:A, y:B(x) \vdash (x, y) : \exists x:A, B(x).
$$
我们也可以将$\exist$记作$\sum$。

dependent sum type、存在量词、dependent product type、全称量词之间的关系还可以通过一种更加直接的方式看出来。
设有$a:\mathrm{Type}$以及$R, T, S:\mathrm{Type} \to \mathrm{Type}$，则泛型类型$T$的构造函数可能是这样的：
$$
\mathtt{cons}: \forall a : \mathrm{Type}, a \to T a,
$$
而某个从$T a$类型的term中“取值”的函数可能形如
$$
\mathtt{uncons}: \forall a : \mathrm{Type}, T a \to S a.
$$
这样的$T a$提供了一个从*任意*的$a$构造$T$类型的模板，我们于是可以称$a$为**universal的类型变量**。
当然，我们也可以推广$\mathrm{cons}$为
$$
\mathtt{cons}: \forall a : \mathrm{Type}, R a \to T a,
$$
$\mathtt{uncons}$同理。现在我们制造以上构造函数和取值函数的存在量词对应，我们可以有这样的构造函数：
$$
\mathtt{cons'}: (\exists a: \mathrm{Type}, Ra) \to T',
$$
即从*某个*类型的term出发可以构造一个$T'$类型的term，而从$T'$类型的term中“取值”的函数可以形如
$$
\mathtt{uncons'}: T' \to (\exists a: \mathrm{Type}, S' a).
$$
此时的类型变量$a$不再可以随意代入一个类型，我们称这种类型变量为**existential的类型变量**。
现在我们演示，existential quantifier可以使用universal quantifier表示出来。
使用
$$
(\forall x, A(x) \to B) \Leftrightarrow ((\exists x, A(x)) \to B),
$$
就有
$$
\mathtt{cons'}: \forall a: \mathrm{Type}, Ra \to T',
$$
这意味着
$$
T' = \mathtt{cons'}(\exists a: \mathrm{Type}, Ra) = \forall a: \mathrm{Type}, \mathtt{cons'}(Ra).
$$
有一个构造函数就可以定义一个类型，所以诸如
$$
T' = \mathtt{cons'} (\exists a: \mathrm{Type}, Ra) | \cdots
$$
的定义全部可以转化为
$$
T' = \forall a: \mathrm{Type}, \mathtt{cons'}(Ra) | \cdots.
$$

dependent product和dependent sum这两个术语看起来有些迷惑：dependent product type看起来似乎是类型$A \to B$的推广（$A \to B$中$B$是定死的，而dependent product type中$B$依赖于输入值$x$），而dependent sum type似乎是product type的推广（product type的第二个元素是定死的，dependent sum type中第二个元素的类型可以依赖于第一个元素）。
实际上的确有人将dependent sum type称为dependent product type，既然它是product type的推广。
dependent product type会被称为product type实际上是因为，考虑
$$
(x_{i_1}, x_{i_2}, \ldots, x_{i_n}) : B_{i_1} \times B_{i_2} \times \cdots B_{i_n},
$$
这个结构保存的信息和一个从$i_k$到$x_{i_k}$的lambda表达式是完全一样的，那么如果所有$i_k$均属于某个类型$A$，我们就有
$$
(x_{i_1}, x_{i_2}, \ldots, x_{i_n}) : \prod_{i:A} B_i,
$$
而
$$
\lambda i_k. x_{i_k} : \forall i:A, B_i,
$$
于是可以取
$$
\prod_{i:A} B_i = \forall i:A, B_i.
$$
当然，如果已经定义过了tuple，那上面两个类型就只能画上$\leftrightarrow$，但是这完全是记号问题了。
另一方面，dependent sum type会被称为sum type则相对好理解，因为存在量词可以看成无穷个命题取$\lor$得到的。这马上导出了一个非常直观的结果：
$$
A \times B = \sum_{x:A} B.
$$
显然这就是自然数求和的推广。

实际上，图灵完备的自然演绎风格的typed lambda calculus按照其强度可以组成一个称为lambda cube的结构，而CoC位于其顶端；因此所有typed lambda calculus实际上都是采用不同的方式对CoC略作阉割得到的。

## 归纳类型



# CIC used in Lean

## 变量和常量

```Lean
-- variable声明之后，但凡在哪里被提到，就会会出现在全称量词后面，constant不会（或者在必要的时候constant可以出现在存在量词后面）
variables A B C : Prop
-- 可以看到variable和constant的颜色还是不一样的
-- 无论是声明variable还是constant都需要显式地做任何合理性证明，即使是false类型的constant也是可以声明的，因为constant实际上是公理
constant D : false
```

## 证明步骤

- `assume`就是获取参数值
- `show`就是返回值（`show A, from B`就是return B : A）
- 函数调用就是函数后面跟一串用空格隔开的term；定理的使用同理

## 数据结构

定义数据结构时会面临一个问题，就是存在性：

## 规约

CoC既然实际上是一种typed lambda calculus，我们肯定要分析一个term怎么被化简。
实际上如果不引入排中律，CoC里面的term都是保证能够停机的。

我们这里先不详细讨论规约，实际上在本节定义的比较简单的CoC中怎么做term化简是非常显然的。

## 常用库

### 集合

从集合到类型：设`S : set T`，则`S`自己对应的类型为`{ x : T // x \in S }`，是`T`的子类型。
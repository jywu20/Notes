# 类型系统

有必要注意Julia的类型系统和一般的函数式编程语言的差别：
- 就类型本身而言，Julia的类型更像是集合而不是类型论中的类型。例如，subtyping在Julia的类型系统中是重要且自然的，虽然它在类型论中是一个相当棘手的feature；又比如Julia允许轻易地创建“只含有一个元素的类型”，可以很容易地做类型的union等。与通常的集合论不同的地方在于，由于类型本身也是对象，我们同时有`Any <: Any`以及`Any :: Any`；如果想将Julia的类型解释为通常的集合论的集合，那么不能将`::`简单地理解为$\in$；我们将在[此处](#julia的类型宇宙)中讨论这是怎么一回事。
- 类型系统的主要用处是用于决定多重派发怎么做，而不是保证程序的正确性
- 变量没有类型；变量仅仅是指向特定的值的标签，值才有类型

## Julia的类型宇宙

- 每一个对象都有一个最准确的类型，即`typeof(x)`。
  - 如果`x`是某个primitive type的元素，那么`typeof(x)`就是该primitive type。
  - 如果`x`是通过下面的方式创建的，那么`typeof(x)`是`DataType`：
    - `primitive type ... end`块，此时`isprimitivetype(x)`求值为`true`，否则为`false`
    - `abstract type ... end`块，此时`isabstracttype(x)`求值为`true`，否则为`false`
    - `struct ... end`块和`mutable struct ... end`块，此时`isstructtype(x)`求值为`true`，否则为`false`
  - 如果`x`是通过`Union{...}`创建的那么`typeof(x)`是`Union`；
  - 如果`x`是通过`... where {...}`创建的那么`typeof(x)`是`UnionAll`。
- Julia类型可以看作集合。
  - Julia允许的从小的集合获得更大的集合的方法包括：
    - 将一个具体数据类型`T`声明为某个抽象数据类型`T'`的子类型。一个程序中，抽象类型`T'`是所有被声明为`T <: T'`的`T`的并集。
    - `Union{T1, T2, ...}`，即$\cup_{i} T_i$
    - `... where {...}`表达式，即集合$\{\cdots | \cdots \}$
  - Julia支持的其它集合运算包括：
    - `typeintersect`，交集
    - 
- `::`和`<:`的一些定义如下：
  - `A <: B`求值为`true`，当且仅当$A \subset B$
  - `::`关系稍微复杂一些
    - `x :: T`在$x \in T$时求值为`x`。
      - 如果`typeof(x)`是`T`并且$T \sube T'$，则`x::T'`求值为`x`。
      - 如果`x :: DataType`求值为`true`，则`x :: Type{x}`求值为`x`
    - `DataType`和`Any`的一些特殊情况：
      - `DataType :: DataType`求值为`DataType`
      - `Any :: Any`求值为`Any`
      - `Any :: DataType`求值为`Any`
    - 其余情况下`x::T`求值时抛出一个`TypeError`
- 以下是几个集合或者说类型的定义：
  - `DataType`是所有可能是`typeof`输出的东西的集合。它包括：
    - 全体primitive types（或者说，`DataType`的元素中有`Int64, AbstractFloat`这些东西）
    - 全体structs和mutable structs
    - 全体unions
    - 全体UnionAll
  - `Any`是以下集合的并集：
    - 全体primitive types（或者说，`Any`的元素中有1, 2, 3, 'a', 1.3这些东西）
    - `DataType`
    - `Type{DataType}`
  - 按照上面的做法，`Any`本身是一个合法的类型，从而是Julia中的对象，但是它自己无法确定类型。所以我们只能让`Any::Any`。
  这样一来，`::`就不再是$\in$了。类似的，`DataType::DataType`也必须是正确的，否则只能让`typeof(DataType)`求值为`Any`，但是一个具体的对象的类型不应该是`Any`。

Julia的编程范式让一件事变得不可能：给函数确定类型，因为这要求我们能够对任意一个指向函数的名称`func`确定类型，但是`func`名下可以有多个方法。

`where`表达式实际上同时支持了generic type和existential type。这和通常的（涉及较多具体计算的那种）数学中的做法是一样的：A where B一方面给出了一个函数关系，一方面给出了全体满足B的变量取值下A构成的集合。

## 子类型的必要性

子类型在纯粹的类型论研究中是比较讨厌的一个东西，因为它不能像其它常见feature一样，通过一个引入规则和一个消去规则非常干脆利落、和其它feature确定正交地被引入。
但在一些情况下子类型是非常有用的。Julia的类型系统可以算是一个例子。多重派发机制显然要求能够有一个比较符合直觉的方式决定一个函数调用发生时哪一份代码被执行，而子类型产生的类型树显然是一个非常方便的选择。

实际上，Julia的子类型机制也就仅仅满足这个目标而已：具体类型不能够以具体类型为父类型，即所有的具体类型都是final的。
这样一方面可以为多重派发提供方便，一方面可以尽可能避免各种subtle的细节，比如说关于继承的种种复杂之处。

## “动态性”、运行时模板和多重派发

Julia可以被看成动态语言被阉割掉一部分动态性的产物，也可以看成往静态语言中embed少量动态性的产物。

Julia的“类型”实际上同时出现在两个地方：
- 一个是运行时对值的标注，“类型”（或者说“tag”）可以被像普通的值一样传递和处理，如果单纯考虑这种“类型”，那其实就是标准的动态类型语言，和Python等完全没有区别，我们可以把这样一个语言很容易地embed进一个静态强类型语言中，只需要让所有值都是`Dynamic<Representation, Tag>`类型的即可。我们写下`x::T`，就是为了动态确认`x`确实具有类型`T`。
- 一个是变量类型声明（`a::T`）、类型定义（定义`struct`等），这些东西写起来很像静态类型语言。
两种“类型”是打通的。

这是Julia易于优化的原因之一，即Julia被适当地设计为这样一种样子：一个feature既能够被理解成动态语言的，又能够被理解成静态的。
我们下面还将多次看到这种现象。

### 运行时的多重派发

为了简化代码编写，我们需要允许不同的函数共享一个名称。其结果是，当一个函数调用出现时，需要有某个机制来决定运行哪一份代码。Julia中通常将共用一个名字的不同函数称为不同的“方法”。也即，需要有一个机制将一个函数调用派发到特定的方法上。

Julia通过多重派发满足这个需求。常见的面向对象语言使用单重派发，也即，当看到一个类型为`T`的对象`obj`上出现了一个函数调用`obj.method(x)`时，根据`obj`的实际类型（可能是`T`的某个子类型）来决定调用哪一个方法。
多重派发则没有“对象上的方法”这个概念：或者说它相当于`(x1, x2, ...).method()`。

多重派发提供了一种“运行时的模板机制”。如果一个方法的所有参数的类型都是具体类型，那么对它的调用和静态语言中没有任何区别。
反之，如果一个方法有参数是抽象类型，因为实际会传给这个方法的任何值都有完全确定的类型且一定是具体类型；这个有参数是抽象类型的方法被调用时的行为仍然不是完全确定的，而取决于传给该方法的值的具体类型，因为该方法的内部实现会触发另一次多重派发（例如，考虑一个抽象的`sum`函数：它的内部会调用`+`操作，而编译期我们并不知道这个`+`操作会被派发到哪一个方法上面）。
那么它可以按照两种方法理解：
- 依照定义，它是一种subtyping polymorphism。
- 它也可以被理解成一种模板函数，即如果编译器能够确定传入的实参的类型，那么就可以将这个有参数是抽象类型的方法具体化为一段完全静态的代码。

### Julia的动态性

Julia中动态性是确实存在的，而不仅仅是强大的类型推导造成的幻觉：例如，可以在Julia中写出这样的函数，它根据输入值的不同，产生不同类型的输出值（例如，如果输入值是ATGC四个字母组成的字符串那么输出一个表示DNA序列的结构体，否则输出原本的字符串），这不会造成任何错误，因为没有发生“对值进行操作时发现这个值的类型不支持对应的操作”。
但是这种动态性与完全的动态语言又不一样——一段程序最终会转化为对基本操作（加减乘除等）的调用，在完全的动态语言中，只有一个“+”，它内部也许会根据输入的操作数的类型不同选择不同的处理流程，也许会有数据类型转化，而在Julia中，有好多个完全指定了操作数的类型的“+”，在“a+b”形式的表达式被求值时，调用哪一个加法由多重派发机制自动决定。

### 与纯粹的静态语言的不同之处

Julia的多重派发机制相比普通的模板机制使用起来更加方便，因为很多时候无需手动指定类型参数，多重派发会自动找到应该调用的方法。
不过，普通的模板机制配合上足够强大的类型推导也可以做到这一点。
这两者本质的差别在于Julia的动态性：在编译期，一个函数调用会调用哪一个方法在静态类型语言中是完全确定的，而在Julia中则不是这样，也即，模板展开可能是在运行期进行的。
例如，`sum`函数可能是一个模板函数，读入一个可以相加的类型，输出一个具体的求和函数（或者说，所有参数的类型都是具体类型的方法），在静态类型语言中，类型推导意味着我们可以写`sum(arr)`而不显式给出类型参数的值，但是为了正确推导类型，`arr`的类型必须要知道；当然，也许`arr`的类型也没有显式声明，但是生成`arr`的子程序的返回类型必须要知道……这样一路向前追溯，最终必须能够追溯到一些类型常量，只有这样才能够在编译期将所有的类型确定下来。
反之，在Julia中，完全可以写出诸如这样的代码：从一个文件读入一个序列，根据这个序列中的数有没有小数点决定是把它转化为一个`Array{Int64}`还是一个`Array{Float64}`，然后传给`sum`求和。
换句话说，`sum`直到运行期都保持模板函数的特性，只有当一个`Array{Int64}`或是一个`Array{Float64}`被传入时才决定执行哪个版本。
（这种动态性同样意味着类型tag应该能够在运行时被提取、处理，这也就是Julia中类型也是对象的原因）

### 对动态性的限制

另一方面，相比于完全的动态语言，Julia也有一些事情是不能做的。一个完全的动态语言应该允许这样的操作：定义一个函数，读入一个未知的数据，然后动态地产生一个`struct`。
这在Julia中是不被允许的。这也就是需要在`(args)`之外再引入`{args}`的原因之一。
大部分的模板函数的类型参数都可以作为普通的`(args)`参数传入，而模板结构体则必须要用`{args}`。

# 宏

Julia具有非常像Lisp的宏。主要的不同之处在于Julia宏操作的AST的格式并非S expression那种`(+ 1 2)`型的，而是由`Symbol`, `Expr`等类型的对象组成的；分号用`LineNumberNode`表示。

# 一些细碎点

可变`struct`一般是很少用到的，但这不会让代码变得奇怪，因为有内部状态的“容器”（如`Dict`, `Array`）足以承担大部分可变性。
修改它们不需要赋值。
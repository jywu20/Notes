# 彼此冲突和合作的若干流派

- 写语法派：Basic Linguistic Theory
  - 人物：Dixon, Marie-Lucie Tarpent, van Driem, 以及很多languagehat.com上的人
  - Descriptive theories, explanatory theories, and Basic Linguistic Theory by Matthew S. Dryer
  - 这些人会出现的会议：https://grammar2021.sciencesconf.org/resource/page/id/1
  - 怒喷生成和类型学：A holistic approach to the fine art of grammar writing: The Dallas Manifesto
- 功能类型学派：
  - Dryer, Haspelmath, WALS
  - Framework-free grammatical theory by Martin Haspelmath 认为，Dixon等人虽然自称“完全基于语言自身的概念来描写语言”，但是他们要求语法编纂者“熟悉Basic Linguistic Theory”，所以实际上仍然是在干生成语法那些人在干的事情。纯血类型学和语法作者的冲突……有趣……
  - 对生成的反对：https://inference-review.com/letter/reassessing-the-legacy-of-aspects
  - Frederick J. Newmeyer, Possible and probable languages: a generative perspective on linguistic typology. Oxford: Oxford University Press, 2005. Pp. x+278. Book review.
  - 对生成的支持：https://ling.auf.net/lingbuzz/006337
- 生成派
  - Cinque和cartography, Mark Cleland Baker和formal generative typology
  - Deriving the functional hierarchy by G Ramchand, P Svenonius: generative syntax和functionalism的某种统一
  - 关于CP, TP, vP为什么必要可能在Core syntax一书中有
  - 引入功能性解释的一些尝试：https://ling.auf.net/lingbuzz/006300

# 一些我觉得没啥意思的讨论

- 神经网络能不能捕捉到传统上认为是UG的东西；既然最简方案要求的innate structure building本来就是非常自然的，神经网络当然能够捕捉到……

# 生成语法和functional-typological方法的统一

https://ling.auf.net/lingbuzz/006337值得全文阅读。

## "Describing each language according to its own term"

Haspelmath这种人认为：
- 应当直接看着每种语言的语法，做“无理论框架前提”的grammar writing，这样分析得到的语法范畴记作X
- 从各个X抽象出Y，用于做类型学分析；注意Y只是类型学tag，不是真实存在在实际语言中的
- 例子：X是每种语言实际上的格标记；同样被称为“dative”的格在不同的语言中会覆盖有所不同的范围，因此实际上是彼此不相同的；Y是抽象的“dative”，用来做类型学比较研究

然而，Haspelmath的论证不能导出Y在具体的语言中就不存在的结论。实际上完全可以是具体的语言也具有Y，然后还有一些语言特异的特征，从而X=Y+Z。
当然，这就是principle and parameter式的研究了。Y部分来自普遍语法，部分来自functional perspectives。

实际上在functional-typological的研究中，也有声音认为教条地理解"Describing each language according to its own term"是不可取的，因为奥卡姆剃刀倾向于使用了较少的概念的理论。
抽象概念并不更加不真实：音系学概念比语音学概念更加抽象，可是在编写参考语法时大家一般会更加关注音系而不是语音。

无论如何，"Describing each language according to its own term"这个口号确实是有价值的；不能够看到什么东西就把它归结到UG当中！
生成语法归结到UG里面的东西必须是严格意义上的**形式普遍性**：c-command等等。具体“有多少个格”这种东西需要更加functional-typological的理解；通过研究日耳曼语和罗曼语得到的所谓“UG特征”很可能反映的是印欧语的类型学，而不是UG。

当然也应该注意到，functional typological依据"Describing each language according to its own term"对生成语法支持者的指责有些时候是不太对头的。
比如说，他们会指责，生成语法将所有的nominal expression都建模成DP，说明生成语法实在是没有"Describing each language according to its own term"。
但实际上不是这样的：有很多生成语法学家如今认为，DP hypothesis实际上并不是好的universalist的理论，因为如果我们接受DP hypothesis，为了解释缺乏显式冠词的语言为什么对out-of-NP-movement更加宽容，就需要认为D在这些语言中一来没有语音实现，二来不构成一个phase。
但是这样实际上是认为不同语言对locality的定义是不同的，这就看起来非常奇怪了，因为很难想象对locality的要求竟然能够编码在词库中，而现代generative morphosyntax是认为所有语言差异都尽可能要编码进词库中的（Borer-Chomsky conjecture）。
所以，实际上生成语法中也有很多人是"Describing each language according to its own term"的。

实际上DP hypothesis还有一个很大的漏洞。隐式的D一般认为是为了确定一个nominal expression的指称，好让它能够做argument。
但是实际上语义学分析是*反对*DP hypothesis的：考虑汉语普通话中的句子：
>  每一个有一头驴的农夫都会打驴的。
> 
> 农夫要是有了头驴，绝对要打驴的。

这句话中的第二个“驴”的指称是完全不定的：说话人可能想说，没有驴的农民比较穷，觉得驴很贵重，但是实际上有了驴以后感觉驴不干活了就要打它，看到别的驴也要打。
如果是下面的句子：
> 每一个有一头驴的农夫都会打他那头驴的。

那后一个“驴”和前一个“驴”就是同指的。比较英语的
> Every farmer that has a donkey beats the donkey.

可以看到前后两个donkey是同指的。我们发现，认为汉语默认就有D完全说不通，因为默认有D的话，那么前后两个驴无论有没有“他那头”都应该是同指的。

与DP的例子类似，cartography中的功能层级可以被认为是在任何语言中都存在的，但是不同的语言有不同的语音实现、movement trigger和locality要求，也可以被认为是“零售”的，但是层级顺序体现出很强的一致性。

## 句法作为工具

functionalist更多地认为句法除了体现深层的语义和语用关系以外毫无值得分析之处；不过与其说这体现了和生成语法的世界观不同，倒不如说体现了方法论的不同：前者更多关注什么是可能的，而后者希望找到什么是不可能的。

典型的例子就是作格动词的问题：类型学家会抱怨生成语法学家没能够考虑work和arrive*为什么*会存在深层结构的差别。的确，这个问题必须使用functional的理论解释；但是另一方面，类型学家满足于做完功能的解释以后就不管句法了。

生成语法和functional typological的差别是互补的，不是对立的。

## typological universal和UG

一个常见的问题是Greenberg式的language universal和普遍语法之间是什么关系。从生成语法的视角，Greenberg-style language universal是普遍语法的*定理*而不是*公理*：UG + functional considerations = Greenberg-style language universal。
由于功能性的东西是“可有可无”的，Greenberg-style language universal也不是必然成立的，所以是允许例外的。

一个例子：格标记和自由语序总是一起出现。这显然是一个功能性的现象，因为如果语序不固定，就需要格标记来标记论元。
但是另一方面，缺少定冠词和自由语序似乎也存在类型学关系。这缺乏功能性的解释，很可能是来自syntax proper。

## 语言的最优设计

## 语言习得

# language universal作为历史演化倾向

参见 Haspelmath, Can cross-linguistic regularities be explained by constraints on change? 一文，收录于Explanation in typology一书。

语言的类型学共性可以使用不同的causal factor来解释，也称为constraint，如果比较弱，就称为preference，比较强就称为restriction。
constraint包括：
- functional-adaptive constraints，即为了达到某个功能，语言应该具有某些特性（如前述的自由语序的语言通常有格标记）；“适应”一词强调了这类constraint的解释能力
  - 有些人指责这类constraint没有给出语言演化的路径，但弛豫足够快时我们确实也不需要注意弛豫过程
- representational constraints，生成语法通常会有的约束，也包括认知语法的约束，即某些种类的语言构造不会出现是因为它们有违人类的认知能力；通常（归结为UG的）representational constraint都是硬约束，虽然也可以是软的（如default parameter，在没有其它信息时，遇到某个语言结构的reanalysis倾向等等）
- mutational constraint，语言历时演化中的倾向，这又包括
  - result-oriented constraint，语言社群会倾向符合functional-adaptive constraint的语法，即语言历时演化起到的是统计物理中弛豫力的角色
  - source-oriented constraint，即语言演化过程本身决定了演化产出，如介词在名词前面的语言一般来说possessor在主要名词后面，因为介词很多时候是dative语法化而来的（because of NP < by cause of NP）
  - 一些人认为functional-adaptive constraints和representational constraints并不重要，只有mutational constraint重要，但是很多不同的演变路径最后收敛到了同一个结果上面，因此functional-adaptive constraints确实是重要的
- acquisitional constraint，特定类型的语言更容易被习得，和representational constraint存在重合（这么说是不是也可以把和parsing有关的软representational constraint单独列出来）

在解释一个language universal时，建议首先invoke mutational constraint，然后是functional-adaptive，再然后是representational constraint，因为最前一个是可以直接观察到的，第二个有些玄学，第三个是非常general的，感觉非常万金油，就是说越往前的理论解释的cost越小（奥卡姆剃刀原则）。

# 语法范畴的普遍性和generative-typology的可能性

见The universal structure of categories: Towards a formal typology by Martina Wiltschko

语言可以看成一系列unit of language (UoL)构成，包括单个的词（determiner, complementizer）、固定不动没啥特征扩散的前后缀（possessive, progressive）、特征（tense, number, case）、clause-type等等；它们都可以定位到句法树上的某个节点。
一系列具有类似分布的UoL组成一个category。很自然的问题是为什么会有category这样的一类彼此可以替换的UoL存在。需要问的问题包括
- category的来源，UG还是usage
- how universal are they
- 如何从一个语言内定位出一系列category

可以通过describe a language in its own terms的方式识别出一些category，如英语助动词总是在主动词之前、能够反映时态和主谓一致性、参与subject-auxiliary inversion。
这样的方法无法定位跨语言的category。

# 各路人物

- [Haspelmath's twitter](https://twitter.com/haspelmath) and [his blog](https://dlc.hypotheses.org/author/dlc)
- [Hornstein](http://facultyoflanguage.blogspot.com/)
- [Omer Preminger](https://omer.lingsite.org/)
最简方案的learner
======

我们讨论一个基于one head one feature、cyclic spellout、phase、span spellout的最简语法，同时有概率性（我知道一些人会反对这个说法，但是这样有实践上的好处）的最朴素的learner应该怎么设计。一个learner肯定包含某种parser，不过我们这里不去讨论parser的细节，因为如果要仔细讨论的话，更加高效的parser显然是必要的，但是眼下看起来还不是很现实。
如果是以神经网络parser来提高效率，那么我们就是在面对“如何将语言学知识融入神经网络”的技术性问题，并非一个非常语言学的问题；如果试图开发一个基于规则的parser，那么首先这条路早就有人做过了，但是难以scale up（Penn Treebank算是这种尝试的一个结果），其次由于最简方案社区经常改动规则，这样的parser肯定面对理论的变动是不robust的。

# 树的生成

树的生成可以当成一个随机过程。面对

# 贝叶斯方法

在已知句子$x$时，应该通过以下标准的贝叶斯方法建立树并且给树$y$打分：
$$
p(y|x) = \frac{p(y) p(x | y)}{\sum_{y} p(y) p(x | y) }
$$
由于在树已知时$p(x|y)$不是1就是零，我们有
$$
p(y|x) = \frac{p(y)}{\sum_{y \text{ spells to } x} p(y)}.
$$
当然这就比穷举没有高明到哪里去了……
$p(y)$可以通过之前的

关键点：先验概率的更新
# Minimalist Syntax

## Notes about language Minimalism

### What Minimalism is all about

We say Minimalism is a *framework* rather then a certain kind of theory. Different theories may be developed under the framework, while they have shared assumptions about what is nature language. 

| Approach               | Framework          | Theory    |
| :--------------------- | :----------------- | :-------- | 
| generative linguistics | Minimalist Program | Minimalist Grammar |
| generative linguistics | Minimalist Program | Minimalist Machine |
| generative linguistics | Minimalist Program | Agreement-based theories |
| generative linguistics | Principle and Parameter (in narrow sense) | Something |

Basic ideas in Minimalism can be concluded as follows:
- A syntactic tree is a binary, ordered and headed tree. 
- A syntactic tree is built in a bottom-up manner via a simple operator called *Merge*, which takes two constituents and combined them into one larger constituent.
- (**Inclusive Condition**) Lexicon is the only information source. 

We can get a intuitional grasp of correlation of these conditions. Obviously, *Merge* is not capable to combine more then to constituents into one to avoid violation of the binary attribute of syntactic trees. 

Inclusive Condition entails items like *Empty Operators* or *traces* commonly found in GB theory is no longer available in Minimalist syntax, because an empty operator or a trace is something "inserted" into the tree when it undergoes certain kinds of operations, like movement. We see *before* they are inserted, all words used in the tree are already picked up from the lexicon, so insertion of them runs counter to Inclusive Condition.

### Principle and parameter

When we refer to P&P framework, we are denoting either one of
- P&P in the narrow sense, that is GB theory and related theories
- P&P in the broad sense, which includes GB theory, Minimalist theories and maybe much more theories outside the mainstream.

P&P in the broad sense claims that Language, or the language faculty of human beings, consists of
- a finite set of principles which holds true in every possible nature language, and
- a finite set of parameters by which languages display discrepancy.

Minimalist program is of course a subset of P&P in the broad sense given that all Minimalist accounts of syntax make the same set of assumptions of how syntactic structures are built, which consist a typical type of principles, and since in MP the lexicon contains *all* information that define a language, it is also parameterized.

Note: *Here comes a problem about finiteness.*

### About parameters

In GB theory, principles themselves are parameterized, while in MP, parameters are stored in the lexicon. TODO

### Some notes about constraints
A typical minimalist approach of investigation into parameters is to attribute it to feature configuration in the lexicon. We know that parameters, either micro or macro ones, can be deconstructed into a set of features, eliminating building bricks of our theory, so the question is, whether a similar approach can be applied to encode *principles* into more fundamental elements.

Contrary to GB theory where a syntactic tree is derived by building up a D-structure using a CFG (X-Bar schema and lexical selection) and then moving, copying or deleting certain projections of it which is guided by a set of principles, in Minimalist framework we employ a bottom-up algorithm. Therefore, any constraint that involves global knowledge about the *whole* tree should be placed at interfaces where the whole structure is formed, waiting for phonetic implementation or connection with logic rules. Applying a global constraint to a tree on building is computationally impossible given that simply *no* global information is accessible when the tree is not completed.

### Derivational Syntax or not

We say a grammar is strictly derivational if any sentences it allows can be obtained by applying a set of operators to a set of primary elements with finite times. Constraints at interfaces render a grammar not derivational because constraints *reject* certain structures rather then *generate* correct structures. Therefore, not all syntaxes in MP is derivational because a large bunch of them use constraints.

From a computational perspective, a non-derivational syntax is much computationally hard because standard bottom-up parsers can not parse the language it generates. Nonetheless, allowance of constraints provides rich descriptive tools of syntax.

Note that if the language generated by a derivational syntax can be parsed, the language generated by the syntax constructed by adding extended constraints to the first syntax can also be parsed by the same parser. Therefore, even if strictly derivational syntax is not plausible model of language, it is still of industrial value in NLP.

## Formalism

Now it is time to turn those ideas into rigorous formalizations. First we need to define a few terms.

- **lexical entry**: an inseparable bundle of features, either interpretable ones like semantic or phonetic features, or uninterpretable ones like selectional features or unvalued features.
- **feature**: a key-value pair, representing some properties of a lexical entry. Features may be valued or unvalued.
- **constituent** or **constituency**
- **workspace**: a set of half-built trees stored in working memory of mind. We assume that trees in workspace are separate - no node has two parents.
- **chain**

### Derivation


### Fundamental Operations
Minimalist program specifies a bottom-up mechanism of structure building. *Merge*, or combining two constituents into a larger one, is the major - and possibly only - structure building operations. Besides Merge, there remains several operations like Move or Delete, and maybe Adjoin. Some of the operations listed are fundamental operations: they enjoy their status as building blocks of the whole grammar system. Other are combination of fundamental operations. There is a tendency in natural language that the simpler a operation is, the more likely it will be frequently used.

We present two sets of fundamental operations here. They correspond with Minimalist Machine by Sandiway Fong and Minimalist Grammar by Edwards Stabler, respectively. 

#### Framework with probe-goal mechanism and copy theory of movement

In this framework we designate **Merge**, **Agree** and **Delete** as primary operations.

$$
\text{Merge}: \{\alpha, \beta, \ldots\} \rightarrow \{[_{\alpha} \;\alpha \; \beta], \ldots\} \; \text{or} \; \{[_{\alpha} \;\beta \; \alpha], \ldots\}.
$$
Merge picks out two constituents from the workspace and creates a **binary**, **ordered** and **endocentric** structure by combining them into one. (Notice the subscript denotes the head of the structure) 

Note that from our restriction of workspace $\alpha$ and $\beta$ cannot be each one's subtree. However, this restriction may be loosened a little if we consider another operation: Copy.

$$
\text{Copy}: \{[\ldots \alpha \ldots], \ldots\} \rightarrow \{[\ldots \alpha \ldots], \alpha , \ldots \}
$$ 
Copy merely makes an exact replicate of an existing tree in the workspace. $\alpha$ may be or may not be a subtree of a larger tree.

By introducing Copy, we can extend Merge to the case in which $\beta$ is a subtree of $\alpha$. Consider the following process: first $\beta$ is Copied into the workspace and then the copy is merged with $\alpha$ to form a larger constituent. Now we have the following combined operation:
$$
\{[\ldots \beta \ldots], \ldots\} \rightarrow \{[_> \; \beta \;[\ldots \beta \ldots]], \ldots\}
$$

$>$ means the latter one in brackets is the head. $\beta$ is thus copied and raised to a higher place in the tree. We call this process Internal Merge (in contrast to External Merge in which $\alpha, \beta$ are separate)

Since at the final stage of derivation there remains only one tree in the workspace, every constituent Copied into the workspace undergoes Internal Merge sooner or later. Therefore we can combine Copy and External Merge into a single Merge that allows both Internal and External Merge:

$$
\text{Merge}: \{\alpha, \beta, \ldots\} \rightarrow \{[_{\alpha} \;\alpha \; \beta], \ldots\} \; \text{or} \; \{[_{\alpha} \;\beta \; \alpha], \ldots\} \; \text{when $\alpha$ is not a subtree of $\beta$}.
$$ 

External Merge is a local operation, while Internal Merge is not, since it involves the inner structure of $\alpha$. Existence of non-local operation is not astonishing considering CFG is not sufficient for descriptive purpose. Yet sometimes we need another type of non-local operation - what we want to move may not be a constituent, but rather, a feature. This demands can be satisfied by another operation - Agree.

$$
\text{Agree}: \{ \alpha_{[u\mathrm{F}]}, [\ldots \beta_{[\mathrm{aF}]} \ldots], \ldots \} \rightarrow \{\alpha_{[\mathrm{aF}]}, [\ldots \beta_{[\mathrm{aF}]} \ldots] , \ldots\}, \\
\text{or} \; \{\alpha_{[\mathrm{aF}]}, [\ldots \beta_{[u\mathrm{F}]} \ldots], \ldots \} \rightarrow \{\alpha_{[\mathrm{aF}]}, [\ldots \beta_{[\mathrm{aF}]} \ldots] , \ldots\}, \\
\text{or} \; \{\alpha, [\ldots \beta_{[u\mathrm{F}]} \ldots], \ldots \} \rightarrow \{\alpha, [ \ldots \beta_{[\mathrm{aF}]} \ldots] , \ldots\}, \\
\text{where $\alpha$, $\beta$ are heads.}
$$
Agree is a relatively complex operation, which is actually a composition of several similar - but not identical - operations. Unvalued features on one participant get their values as copies of correspondent values on another. $\alpha$ may also designate certain features to $\beta$ even if $\alpha$ does not bear the corresponding features.

Note that we do not stipulate that $\alpha$ c-commands $\beta$. If we require c-commanding condition, some questions arise when it comes syncretized heads, or several heads merged together forming a larger head. Consider this example: *hadn't* is formed by merging a auxiliary verb together with a negative suffix and then with a tense affix) It is obvious that in a clause containing hadn't as its main verb, T is involved into three operations: Merge1 (T, or the syncretized head containing T, is merged into the tree), Agree (T agrees with the subject and assigns nominative case to it), and another Merge2 (T is merged with the verb, as a result of V to T movement). Now assume T must c-commands the subject for a successful agreement. Agree cannot be the first operation taking place, since T must be on the same tree with the subject for a legal Agree. If Merge2 is the first operation, then Merge1 must be the second operation to get T attached to the tree for Agree to take place. But Agree still fails - after Merge2 and Merge1, the initial T no longer c-commands the subject. What c-commands the subject now is the syncretized head, which is, structurally, an analogue of intermediate projection. Theoretic puzzles like whether probing features can be preserved after merging and that something "outside the tree" like feature chain is inevitable for an intermediate projection to probe condemn this approach as unpractical. If Merge1 is the first operation, Merge2 becomes a trouble maker. Given that we do not have operations to take things down from the tree, once T is merged to a tree it is impossible to merge it with a verb to form a complex head. Hence we get the conclusion that requiring $\alpha$ to c-command $\beta$ is incompatible with head movement.

But if $\alpha$ does not necessarily c-command $\beta$, how do we know what $\beta$ is the right one to Agree with? This question implies that we need some conditions to restrain overuse of Agree to prevent overgeneration. A possible approach is to define a set of compositional operations and constrain the usage of Agree to them.

And now it comes the last kind of operation: Delete. This is actually the most controversial operation mentioned here. In lexicalist approaches, Delete is described as removing an item from the tree, while in Distributed Morphology, to Delete something means to give it null phonetic realization. Anyway, we can describe Delete as adding one "deleted" mark on something:
$$
\text{Delete}: \{[ \ldots\alpha \ldots], \ldots \} \rightarrow \{[\ldots \sout{\alpha} \ldots], \ldots \}.
$$ 

In the present notion of Deletion, we stipulate that the deleted string must form a constituent, as is referred as $\alpha$. It is intriguing, though, that in some cases deletion seems to be applied to non-constituent strings. Consider the example:

*What hope is there of finding survivors?*

Under the hypothesis that the nominal expression involved here has its structure as [Q [N [PP]]], the sentence may be analyzed as 

[<sub>QP</sub> What [<sub>NP</sub> hope <del>[<sub>PP</sub> of finding survivors]</del>]] is there [<sub>QP</sub> <del>what</del> [<sub>NP</sub> <del>hope</del> [<sub>PP</sub> of finding survivors]]]?

Deletion of PP is not surprising; what is unexpected is *what hope* is deleted as a whole while they do not form a constituent. This being true, we are obliged to extend the scope of Deletion to non-constituent deletion, which in turn gives rise to the question when non-constituent deletion is possible.

Could this be PF deletion or something?

### Types of features

### Compositional operations
phrasal movement, head movement, reconstruction, affix lowering

#### Affix lowering

#### Movement
Phrasal movement means to displace a phrase - or, a maximal projection. 

$$
\mathrm{PMove}: \{[_\alpha \; \alpha \; [\ldots \beta \ldots]], \ldots\} \rightarrow \{[_> \; \beta \; [_\alpha \; \alpha \; [\ldots \sout{\beta} \ldots]]], \ldots\} \text{ where $\alpha$ is a head. The relative order is irrelevant.}
$$

1. $\beta$ is copied into the workspace
2. $\beta$ 's copy is merged to the tree headed by $\alpha$
3. Original $\beta$ is deleted

In the case of covert phrasal movement, the copy of $\beta$ instead of the original $\beta$ is deleted. Covert movement does not generate overt displacement, but it changes the structure and may lead to semantic variation. Another related operation is copying, in which step 3 is omitted and both copies of $\beta$ has spellout.

Another type of non-standard movement involves *discontinuous spellout*, as is found in sentences like *What hope could there be of finding any survivors?*, in which part of a moved phrase is spelled out in the position in which it originates, and the remainder in the position in which it ends up.

$$
\mathrm{HMove}: \{\alpha, [\ldots \beta \ldots], \ldots\} \rightarrow \{[[_\alpha \; \alpha\beta] [\ldots \sout{\beta} \ldots]], \ldots\} \text{ where $\alpha$ is a head. The relative order is irrelevant.}
$$

1. $\beta$ is copied into the workspace
2. $\alpha$ and $\beta$ are merged into a syncretized head
3. The syncretized head is merged with the tree with the original $\beta$
4. Original $\beta$ is deleted

These two kinds of operation may be combined into a larger operation: Extended Merge.

$$
\mathrm{ExtMerge}: \{{\alpha, [\ldots \beta_1 \ldots \beta_2 \ldots \beta_n \ldots]}, \ldots \} \rightarrow \{[\beta_{i_1} \ldots \beta_{i_m} \ldots \alpha \ldots], \ldots\} \\
\text{where $\alpha$ may or may not be merged with one or more heads}
$$

1. A head $\alpha$ agrees with one or more heads among $\beta$s, if $\alpha$ has any uninterpretable features. Affix lowering and similar phenomena happens at this stage.
2. If $\alpha$ is a strong affix, that is, it triggers head movement, then the head of its complement undergoes head movement and is merged with $\alpha$. If such head movement is not possible, then try to copy $\alpha$'s head and do head merge. If $\alpha$ is strong but any copy or move operation is not accessible, the derivation crashes.
3. $\alpha$ is merged into the tree containing $\beta$s.
4. If $\alpha$ (or the syncretized head after step 2) triggers phrasal movement, find the mover and move it to the specifier position of $\alpha$. If movement is not possible (causing ill-formed structures, for example), covert movement or simple copying are performed. If all resorts failed, the derivation crashes.

This Merge-and-Move operation packs all possible operations taking place after something is merged into the tree.

Another type of movement involves two identical syntactic objects. A copy of them is merged into the tree, and the original two objects are deleted. This two-origin operation may be the underlying mechanism of gapping.

### Parameters

Borer-Chomsky conjecture

Question: global constraints, like those found in phonology, cannot be trivially encoded into the lexicon.

## Morphological change

## Operations with features 

### Case and theta-role

### Feature copying, checking and valuation

When a lexical item is merged into a syntactic tree, it may function as a *probe*, which searches for a c-commanded *goal* to agree with. For example, when BE comes into a sentence, it searches for a c-commanded nominal goal to agree with. Let's concentrate on this example. When a nominal item is merged into the structure, its phi-features (that is, its person, number and so on) are determined. We say its phi-features are valued. Meanwhile, its case feature is not checked. On the other hand, BE newly inserted has valued tense feature, while its person and number features remain unvalued. Now BE puts a probe to a nominal item c-commanded by it, and according to the principle of agreement, phi-features of the nominal word are copied to BE, and BE determines that the nominal word's case feature should be nominative case.

[<sub>T'</sub> BE<sub>[Past-Tns][?-Pers][?-Num]</sub> [<sub>VP</sub> arrested [<sub>PRN</sub> THEY<sub>[?-Tns][3-Pers][Pl-Num][?-Case]</sub>]]]

BE dispatches a probe to THEY, and after feature checking and copying, we get

[<sub>T'</sub> BE<sub>[Past-Tns][3-Pers][Pl-Num]</sub> [<sub>VP</sub> arrested [<sub>PRN</sub> THEY<sub>[Past-Tns][3-Pers][Pl-Num][Nom-Case]</sub>]]]

And BE can now be spelled as `were`, and THEY can now be spelled as `they`. So the structure becomes

[<sub>T'</sub> were<sub>[Past-Tns][3-Pers][Pl-Num]</sub> [<sub>VP</sub> arrested [<sub>PRN</sub> they<sub>[Past-Tns][3-Pers][Pl-Num][Nom-Case]</sub>]]]

After a movement, we obtain the complete sentence.

Now here comes the question: how can we formalize this idea into MG? We know in MG both **merge** and **move** only check existing features coming directly from the lexicon. What's even more difficult is the c-commanding relation. How can we formalize the probe mechanism, feature copying and all related issues into MG? 

Here are two main points:
- how to identify the c-commanded constituent, and
- how features of the c-commanded constituent be passed to the constituent directly merged with the newly inserted lexical item.

The first problem occurs because the only long-distance connection in MG is **move**. 

One possible solution: we assume each verb has features of [Num], [Pers], [Tns] and so on, and these kinds of features of all possible specifier it selects should agree with the verb itself. So we eliminate the necessity of the probe mechanism and the feature copying mechanism. 

In this solution, the range of agreement is no longer restricted to the direct c-commanded constituents. 

Another way, probably agreed by more mainstream researchers, is that the probe-goal mechanism is in fact another form of movement, that is, *covert movement*, in which only 


## Why sometimes certain operations seem impossible

